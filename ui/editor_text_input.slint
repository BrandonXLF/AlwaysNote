import { OptionPopup } from "option_popup.slint";
import { ColorPalette } from "color_palette.slint";

export component EditorTextInput {
	in property <[string]> extra-options;
	in-out property <string> text;
	in property <bool> single-line: true;
	in property <TextWrap> wrap;
	in property <brush> color: ColorPalette.opposite;
	out property <bool> has-focus: input.has-focus;
	out property <int> anchor_position_byte_offset: input.anchor_position_byte_offset;
    out property <int> cursor_position_byte_offset: input.cursor_position_byte_offset;

	callback extra-option-chosen(string);
	callback edited;
	callback key-pressed(KeyEvent) -> EventResult;

	public function set-selection-offsets(start: int, end: int) {
		input.set-selection-offsets(start, end);
    }

	forward-focus: input;

	ctx-menu := OptionPopup {
		states [
			extra when extra-options.length > 0: {
				groups: [extra-options, ["Cut", "Copy", "Paste"]];
			}
			basic when extra-options.length == 0: {
				groups: [["Cut", "Copy", "Paste"]];
			}
		]

        option-chosen(option) => {
            if (option == "Cut") {
                input.cut();
            } else if (option == "Copy") {
                input.copy();
            } else if (option == "Paste") {
                input.paste();
            } else {
				extra-option-chosen(option);
			}
        }
    }

	TouchArea {
		pointer-event(e) => {
			if (e.button == PointerEventButton.right && e.kind == PointerEventKind.up) {
				ctx-menu.x = self.mouse-x + 4px;
				ctx-menu.y = self.mouse-y + 4px;
				ctx-menu.show();
			}
		}

		input := TextInput {
			x: 0;
			y: 0;

			width <=> root.width;
			preferred-width <=> root.preferred-width;
			min-width <=> root.min-width;
			max-width <=> root.max-width;
			
			height <=> root.width;
			preferred-height <=> root.preferred-height;
			min-height <=> root.min-height;
			max-height <=> root.max-height;

			text <=> root.text;
			
			selection-foreground-color: ColorPalette.contrast;
			selection-background-color: ColorPalette.accent;
			single-line: root.single-line;
			wrap: root.wrap;
			color: root.color;
			
			edited => {
				edited();
			}

			key-pressed(e) => {
				return key-pressed(e);
			}
		}
	}
}